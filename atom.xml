<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不吃香菜的博客</title>
  
  <subtitle>每天积累一点点，每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-24T11:30:53.729Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yusheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据仓库特性和基本概念</title>
    <link href="http://yoursite.com/2019/04/24/datafactory-2/"/>
    <id>http://yoursite.com/2019/04/24/datafactory-2/</id>
    <published>2019-04-24T08:38:32.000Z</published>
    <updated>2019-04-24T11:30:53.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据仓库特性和基本概念"><a href="#数据仓库特性和基本概念" class="headerlink" title="数据仓库特性和基本概念"></a>数据仓库特性和基本概念</h3><h4 id="数据仓库概念"><a href="#数据仓库概念" class="headerlink" title="数据仓库概念"></a>数据仓库概念</h4><p>​    数据仓库是一个面向主题、集成的、非易失的、随时间变化的用来支持管理人员决策的数据集合。</p><h4 id="数据仓库的特性"><a href="#数据仓库的特性" class="headerlink" title="数据仓库的特性"></a>数据仓库的特性</h4><h5 id="1、面向主题"><a href="#1、面向主题" class="headerlink" title="1、面向主题"></a>1、面向主题</h5><p>​    数据仓库在面向特定业务已经定义好主题，每个主题可以一组相关的表来具体实现。</p><h5 id="2、集成"><a href="#2、集成" class="headerlink" title="2、集成"></a>2、集成</h5><p>​    数据仓库的数据来源于不同的数据源，这些数据进入数据仓库必须进行转换，重新格式化，重新排列和汇总，最后的结果是存在于数据仓库中的单一物理映像。下图（引用自《数据仓库》机械工业出版社 第四版）展示简单的数据处理过程：</p><p><img src="/2019/04/24/datafactory-2/data1.png" alt="1556095801525"></p><a id="more"></a><h5 id="3、非易失性"><a href="#3、非易失性" class="headerlink" title="3、非易失性"></a>3、非易失性</h5><p>​    数据仓库中的数据通常是批量的载入和访问，一般情况下，数据仓库中的数据不进行数据更新，当产生后继变化的时候，一个新的记录就会被写入数据仓库。</p><h5 id="4、随时间变化"><a href="#4、随时间变化" class="headerlink" title="4、随时间变化"></a>4、随时间变化</h5><p>​    时变性的意思就是数据仓库中的每个数据单元只是在某一时间是准确的。</p><h4 id="数据仓库中的基本概念"><a href="#数据仓库中的基本概念" class="headerlink" title="数据仓库中的基本概念"></a>数据仓库中的基本概念</h4><h5 id="1、粒度"><a href="#1、粒度" class="headerlink" title="1、粒度"></a>1、粒度</h5><p>​    粒度指的是数据仓库中数据单元的细节程度或综合程度的级别。粒度级别越低，查询越广泛；反之，粒度级别越高，查询范围越小。</p><p>​    举个简单的例子，假设要知道用户A是否在上星期给气象局打过电话。如果使用低粒度级别的存储方式，数据仓库中会存储A用户所有的通话记录，虽然要遍历很多信息，但是终究是可以找到的；但是如果采用高粒度的存储方式，只存储A用户某一星期的通话次数，就无法确定他是否在上周给气象局打过电话。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据仓库特性和基本概念&quot;&gt;&lt;a href=&quot;#数据仓库特性和基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据仓库特性和基本概念&quot;&gt;&lt;/a&gt;数据仓库特性和基本概念&lt;/h3&gt;&lt;h4 id=&quot;数据仓库概念&quot;&gt;&lt;a href=&quot;#数据仓库概念&quot; class=&quot;headerlink&quot; title=&quot;数据仓库概念&quot;&gt;&lt;/a&gt;数据仓库概念&lt;/h4&gt;&lt;p&gt;​    数据仓库是一个面向主题、集成的、非易失的、随时间变化的用来支持管理人员决策的数据集合。&lt;/p&gt;
&lt;h4 id=&quot;数据仓库的特性&quot;&gt;&lt;a href=&quot;#数据仓库的特性&quot; class=&quot;headerlink&quot; title=&quot;数据仓库的特性&quot;&gt;&lt;/a&gt;数据仓库的特性&lt;/h4&gt;&lt;h5 id=&quot;1、面向主题&quot;&gt;&lt;a href=&quot;#1、面向主题&quot; class=&quot;headerlink&quot; title=&quot;1、面向主题&quot;&gt;&lt;/a&gt;1、面向主题&lt;/h5&gt;&lt;p&gt;​    数据仓库在面向特定业务已经定义好主题，每个主题可以一组相关的表来具体实现。&lt;/p&gt;
&lt;h5 id=&quot;2、集成&quot;&gt;&lt;a href=&quot;#2、集成&quot; class=&quot;headerlink&quot; title=&quot;2、集成&quot;&gt;&lt;/a&gt;2、集成&lt;/h5&gt;&lt;p&gt;​    数据仓库的数据来源于不同的数据源，这些数据进入数据仓库必须进行转换，重新格式化，重新排列和汇总，最后的结果是存在于数据仓库中的单一物理映像。下图（引用自《数据仓库》机械工业出版社 第四版）展示简单的数据处理过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/24/datafactory-2/data1.png&quot; alt=&quot;1556095801525&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="数据仓库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库绪论</title>
    <link href="http://yoursite.com/2019/04/24/datafactory-1/"/>
    <id>http://yoursite.com/2019/04/24/datafactory-1/</id>
    <published>2019-04-24T07:56:06.000Z</published>
    <updated>2019-04-24T08:36:23.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据仓库绪论"><a href="#数据仓库绪论" class="headerlink" title="数据仓库绪论"></a>数据仓库绪论</h3><h4 id="体系化的数据仓库环境"><a href="#体系化的数据仓库环境" class="headerlink" title="体系化的数据仓库环境"></a>体系化的数据仓库环境</h4><blockquote><p>体系化的数据仓库的核心，主要存在两种数据：原始数据和导出数据。</p></blockquote><ul><li><p>原始数据是维持企业日常运作产生的真实的数据，而导出数据是经过汇总和计算满足某一业务需求的数据。</p></li><li><p>原始数据可更新，导出数据可以通过重新计算得到，但是不可以更新。</p></li><li><p>原始数据支持日常工作，而导出数据一般都是针对某一业务。</p></li><li><p>原始数据一般是当值数据，而导出数据一般为历史数据。</p></li></ul><blockquote><p>在体系结构化环境中有四个层次的数据：操作层、原子层或数据仓库层、部门层以及个体层。下图（引用自《数据仓库》机械工业出版社 第四版）</p></blockquote><p><img src="/2019/04/24/datafactory-1/data1.png" alt="1556093596898"></p><blockquote><p>体系结构化环境中很重要的一个方面：数据集成，下图（引用自《数据仓库》机械工业出版社 第四版）展示数据集成一个简单的例子</p></blockquote><p><img src="/2019/04/24/datafactory-1/data2.png" alt="1556094193422"></p><blockquote><p>一旦建立数据仓库，就需要对数据仓库进行维护。其中一个很重要的工作就是对数据仓库的性能进行监控，监控的信息可以根据具体的情况进行设计。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据仓库绪论&quot;&gt;&lt;a href=&quot;#数据仓库绪论&quot; class=&quot;headerlink&quot; title=&quot;数据仓库绪论&quot;&gt;&lt;/a&gt;数据仓库绪论&lt;/h3&gt;&lt;h4 id=&quot;体系化的数据仓库环境&quot;&gt;&lt;a href=&quot;#体系化的数据仓库环境&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="数据仓库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>局域网内的邮件服务器搭建</title>
    <link href="http://yoursite.com/2018/11/27/emailserver/"/>
    <id>http://yoursite.com/2018/11/27/emailserver/</id>
    <published>2018-11-27T06:30:04.000Z</published>
    <updated>2018-12-03T07:12:44.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="局域网邮件服务器搭建"><a href="#局域网邮件服务器搭建" class="headerlink" title="局域网邮件服务器搭建"></a>局域网邮件服务器搭建</h2><h4 id="搭建软件环境"><a href="#搭建软件环境" class="headerlink" title="搭建软件环境"></a>搭建软件环境</h4><ul><li>win7 专业版</li><li>mysql 5.5.62</li><li>foxmail 客户端</li><li>hMailServer-5.6.7</li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h4><ul><li>mysql 安装文件<a href="https://pan.baidu.com/s/1WNeocXL7kS067Ri5vhXVIQ" target="_blank" rel="noopener">传送门</a><a id="more"></a></li><li><p>安装mysql软件：</p><ul><li><p>双击mysql安装文件，点击next:</p><p><img src="/2018/11/27/emailserver/mysql1.jpg" alt="1543301529413"></p></li></ul></li></ul><ul><li><p>如果出现如下页面，点击Execute，并按照提示安装完额外安装的软件之后，点击next:</p><p><img src="/2018/11/27/emailserver/mysql2.jpg" alt="1543301650950"></p></li><li><p>点击execute，并且等待软件安装成功</p><p><img src="/2018/11/27/emailserver/mysql3.jpg" alt="1543301764077"></p></li><li><p>出现如下页面继续点击next，不需要改动</p><p><img src="/2018/11/27/emailserver/mysql4.jpg" alt="1543301850777"></p></li><li><p>输入mysql数据库登录密码（记住自己设置的mysql数据库登录密码）</p><p><img src="/2018/11/27/emailserver/mysql5.jpg" alt="1543301982434"></p><p><img src="/2018/11/27/emailserver/mysql6.jpg" alt="1543302035218"></p></li><li><p>查看mysql数据安装的位置，没有自己修改路径的情况下，默认路径在：C:\Program Files\MySQL\MySQL Server 5.5</p></li><li><p>添加mysql到环境变量</p><ul><li><p>将mysql安装目录的bin目录添加到环境变量，本例中的路径就是（C:\Program Files\MySQL\MySQL Server 5.5\bin）</p></li><li><p>在计算机》属性》高级系统设置》环境变量》path，点击编辑，将上述路径填在在最末尾，如果原地址最后没有分号，自己添加英文的分号，然后再将路径添加在后面。</p><p><img src="/2018/11/27/emailserver/mysql7.jpg" alt="1543302348936"></p><p><img src="/2018/11/27/emailserver/mysql8.jpg" alt="1543302421686"></p></li></ul></li></ul><h4 id="安装hMailServer-5-6-7"><a href="#安装hMailServer-5-6-7" class="headerlink" title="安装hMailServer-5.6.7"></a>安装hMailServer-5.6.7</h4><ul><li><p>hMailServer-5.6.7安装文件<a href="https://pan.baidu.com/s/1WTYuhb1yNA_UcOeF0Ffa4g" target="_blank" rel="noopener">传送门</a></p></li><li><p>安装hMailServer软件</p><ul><li><p>点击hMailServer安装文件，点击next，直到出现如下界面</p><p><img src="/2018/11/27/emailserver/hmailserver.jpg" alt="1543300947302"></p><p>点击next出现：</p><p><img src="/2018/11/27/emailserver/hmailserver1.jpg" alt="1543301082037"></p><p>点击next，出现以下界面，这地方要设置密码，用后面登录软件以及添加数据库:</p><p><img src="/2018/11/27/emailserver/hmailserver2.jpg" alt="1543301123482"></p><p>一直点击next或者install，直到出现下面的界面表示安装成功：</p><p><img src="/2018/11/27/emailserver/hmailserver3.jpg" alt="1543301320413"></p></li></ul></li><li><p>设置数据库</p><ul><li><p>打开hMailServer databases客户端，点击next，选择创建新的数据库，选择Mysql：</p><p><img src="/2018/11/27/emailserver/mysql9.jpg" alt="1543303257121"></p><p><img src="/2018/11/27/emailserver/mysql10.jpg" alt="1543303297875"></p></li><li><p>在下面页面中填入mysql对应的参数：</p><p><img src="/2018/11/27/emailserver/mysql11.jpg" alt="1543303439251"></p></li><li><p>点击next后，此处选择mysql55</p><p><img src="/2018/11/27/emailserver/mysql12.jpg" alt="1543303564742"></p></li><li><p>将libmysql.dll文件放入hMailserver安装目录下的bin目录下，如本例就是（C:\Program Files (x86)\hMailServer\Bin），点击next，直到出现下述页面则安装成功。</p><p><img src="/2018/11/27/emailserver/mysql13.jpg" alt="1543303881872"></p></li></ul></li><li><p>添加域名，选择domains，右键add</p><p><img src="/2018/11/27/emailserver/domain.jpg" alt="1543304456017"></p></li><li><p>添加账号，点击accounts，邮件add就可以添加账号：</p><p><img src="/2018/11/27/emailserver/account.jpg" alt="1543304169521"></p><p><img src="/2018/11/27/emailserver/acount2.jpg" alt="1543304343971"></p></li></ul><h1 id="设置foxmail客户端"><a href="#设置foxmail客户端" class="headerlink" title="### 设置foxmail客户端"></a>### 设置foxmail客户端</h1><ul><li><p>安装好foxmail客户端之后点击打开，点击手动设置手动设置</p><p><img src="/2018/11/27/emailserver/foxmail.jpg" alt="1543304712211"></p></li><li><p>以同样的方式设置两个账号，并且相互发送邮件，测试的效果</p><p><img src="/2018/11/27/emailserver/test.jpg" alt="1543304815708"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;局域网邮件服务器搭建&quot;&gt;&lt;a href=&quot;#局域网邮件服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;局域网邮件服务器搭建&quot;&gt;&lt;/a&gt;局域网邮件服务器搭建&lt;/h2&gt;&lt;h4 id=&quot;搭建软件环境&quot;&gt;&lt;a href=&quot;#搭建软件环境&quot; class=&quot;headerlink&quot; title=&quot;搭建软件环境&quot;&gt;&lt;/a&gt;搭建软件环境&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;win7 专业版&lt;/li&gt;
&lt;li&gt;mysql 5.5.62&lt;/li&gt;
&lt;li&gt;foxmail 客户端&lt;/li&gt;
&lt;li&gt;hMailServer-5.6.7&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;搭建步骤&quot;&gt;&lt;a href=&quot;#搭建步骤&quot; class=&quot;headerlink&quot; title=&quot;搭建步骤&quot;&gt;&lt;/a&gt;搭建步骤&lt;/h3&gt;&lt;h4 id=&quot;安装MySQL数据库&quot;&gt;&lt;a href=&quot;#安装MySQL数据库&quot; class=&quot;headerlink&quot; title=&quot;安装MySQL数据库&quot;&gt;&lt;/a&gt;安装MySQL数据库&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;mysql 安装文件&lt;a href=&quot;https://pan.baidu.com/s/1WNeocXL7kS067Ri5vhXVIQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="email" scheme="http://yoursite.com/tags/email/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>不吃香菜的博客</title>
    <link href="http://yoursite.com/2018/11/27/hello-world/"/>
    <id>http://yoursite.com/2018/11/27/hello-world/</id>
    <published>2018-11-27T05:54:50.767Z</published>
    <updated>2018-11-27T05:54:50.767Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，记忆有限，不积跬步，无以至千里！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生苦短，记忆有限，不积跬步，无以至千里！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java基础-字符串</title>
    <link href="http://yoursite.com/2018/09/07/java-string/"/>
    <id>http://yoursite.com/2018/09/07/java-string/</id>
    <published>2018-09-07T06:28:11.000Z</published>
    <updated>2018-11-27T05:54:50.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java基础之字符串"><a href="#java基础之字符串" class="headerlink" title="java基础之字符串"></a>java基础之字符串</h3><h5 id="String、StringBuffer-和StringBuilder三者的区别"><a href="#String、StringBuffer-和StringBuilder三者的区别" class="headerlink" title="String、StringBuffer 和StringBuilder三者的区别"></a>String、StringBuffer 和StringBuilder三者的区别</h5><ul><li>String是字符串常量</li><li>StringBuffer 字符串变量（线程安全）</li><li>StringBuilder 字符串变量（非线程安全）</li></ul><p>String是用final关键字修饰的类，不可以被继承，String变量也是不可变对象，因此每次对String对象操作时，生成新的String对象，二将引用指向新的对象。</p><ul><li>在经常需要改变的字符串尽量不要使用String，而是使用StringBuffer或者StringBuilder。</li><li>StringBuilder是非线程安全的，他的速度要比StringBuffer快，如果不存线程安全问题，优先使用StringBuilder。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java基础之字符串&quot;&gt;&lt;a href=&quot;#java基础之字符串&quot; class=&quot;headerlink&quot; title=&quot;java基础之字符串&quot;&gt;&lt;/a&gt;java基础之字符串&lt;/h3&gt;&lt;h5 id=&quot;String、StringBuffer-和StringBuilde
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>java接口和抽象类</title>
    <link href="http://yoursite.com/2018/09/07/java-education/"/>
    <id>http://yoursite.com/2018/09/07/java-education/</id>
    <published>2018-09-07T03:56:47.000Z</published>
    <updated>2018-11-27T05:54:50.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java接口和抽象类"><a href="#java接口和抽象类" class="headerlink" title="java接口和抽象类"></a>java接口和抽象类</h3><h5 id="java接口的特性"><a href="#java接口的特性" class="headerlink" title="java接口的特性"></a>java接口的特性</h5><p>接口是一种比抽象类更抽象的类，但是接口本身不是类。</p><ul><li>interface里面的方法访问权限默认被申明为public，准确的是说只能申明为public，如果申明为protected、private在编译的时候会出错。</li><li>接口中可以定义成员变量，但是接口中定义的成员变量会被自动申明成public static final常量，可直接通过类名访问。</li><li>接口中不可以有构造方法，且不能创建实例。</li><li>一个接口可以继承多个接口。</li><li>接口中不能含有静态方法。</li><li>接口中定义的方法必须都为抽象方法，但是接口中可以含有默认方法。</li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java抽象类特性"><a href="#java抽象类特性" class="headerlink" title="java抽象类特性"></a>java抽象类特性</h5><p>抽象类定义一种对象的模糊概念，抽象类是用来捕捉子类的通用特性的，不能被实例化，只能作为子类的超类。</p><ul><li>抽象类不能被实例化，但是可以有构造方法，实例化必须得由他的子类完成。</li><li>子类必须实现抽象类中所有的抽象方法，如果有没有实现的抽象方法，子类也必须为抽象方法。</li><li>只要包含一个抽象方法的类就必须定义为抽象类，抽象类可以包含其他方法，抽象类也可以不包含抽象方法。</li><li>abstract不能与final同时修饰一个类。</li><li>abstract不能与private、static、final或native同时修饰一个方法。因为抽象方法是要被实现的，所有抽象方法都不可以用private、final、static关键字修饰。</li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"listen!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java接口和抽象类的区别"><a href="#java接口和抽象类的区别" class="headerlink" title="java接口和抽象类的区别"></a>java接口和抽象类的区别</h5><ul><li><p>接口能够多实现，而抽象类只能单独被继承，其本质就是，一个类能继承多个接口，而只能继承一个抽象类。</p></li><li><p>方法上，抽象类的方法可以用abstract 和public或者protect修饰。而接口默认为public abttact 修饰。</p></li><li><p>抽象类的方法可以有需要子类实现的抽象方法，也可以有具体的方法。而接口在老版本的jdk中，只能有抽象方法，但是Java8版本的接口中，接口可以带有默认方法。</p></li><li><p>属性上，抽象类可以用各种各样的修饰符修饰。而接口的属性是默认的public static final</p></li><li><p>抽象类中可以含有静态代码块和静态方法，而接口不能含有静态方法和静态代码块。</p></li><li><p>抽象类可以含有构造方法，接口不能含有构造方法。</p></li><li><p>设计层面上，抽象类表示的是子类“是不是”属于某一类的子类，接口则表示“有没有”特性“能不能”做这种事。如飞机和鸟都能飞，但是他们在设计上实现一个Fly接口，实现fly()方法。远比两个类继承飞行物抽象类好得多。因为，飞机和鸟有太多的属性不一样。</p></li><li><p>设计层面上，另外一点，抽象类可以是一个模板，因为可以自己带集体方法，所以要加一个实现类都能有的方法，直接在抽象类中写出并实现就好，接口在以前的版本则不行。新版本Java8才有默认方法。</p></li><li><p>既然说到Java 8 那么就来说明，Java8中的接口中的默认方法是可以被多重继承的。而抽象类不行。</p></li><li><p>另外，接口只能继承接口。而抽象类可以继承普通的类，也能继承接口和抽象类。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java接口和抽象类&quot;&gt;&lt;a href=&quot;#java接口和抽象类&quot; class=&quot;headerlink&quot; title=&quot;java接口和抽象类&quot;&gt;&lt;/a&gt;java接口和抽象类&lt;/h3&gt;&lt;h5 id=&quot;java接口的特性&quot;&gt;&lt;a href=&quot;#java接口的特性&quot; c
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java接口" scheme="http://yoursite.com/tags/java%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>几道经典的算法题目</title>
    <link href="http://yoursite.com/2018/09/06/meituan/"/>
    <id>http://yoursite.com/2018/09/06/meituan/</id>
    <published>2018-09-06T07:43:31.000Z</published>
    <updated>2019-04-24T07:45:58.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="美团秋招算法题目"><a href="#美团秋招算法题目" class="headerlink" title="美团秋招算法题目"></a>美团秋招算法题目</h3><h4 id="大富翁游戏"><a href="#大富翁游戏" class="headerlink" title="大富翁游戏"></a>大富翁游戏</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote><p>大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。 </p></blockquote><h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><blockquote><p>这道算法题可以用归纳方法来做，其实也就是斐波那契数列的变种问题。</p><p>假设用f(n)表示玩家走到n步时共有f(n)中走法，所以可以推断出</p><p>f(1) = 1</p><p>f(2) = f(1) + 1 =2</p><p>f(3) = f(2) + f(1) + 1 = 4</p><p>则：</p><p>f(n) = f(n - 1) + f(n - 2) + f(n - 3) + … + f(2) + f(1) + 1 = 2 ^ (n - 1)</p></blockquote><p>有了这个思路，就很容易编写出代码了。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">        System.out.print(<span class="number">1</span> &lt;&lt; (num - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="钱币问题"><a href="#钱币问题" class="headerlink" title="钱币问题"></a>钱币问题</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote><p>给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数。</p></blockquote><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><blockquote><p>这个问题我们可以求解理解为N - 1, N - 5, N - 10, N - 20, N - 50, N - 100这几种情况的和，对于N元我们又可以理解从1～N这些钱的组合数的和。对于N值为1~4只有1种组合，即f(x) = 1 (1 =&lt;  x &lt;= 4)，对于5~9我们有2中组合，即f(x) = f(x - 5) + 1 (5=&lt;  x &lt;= 9)，一次类推下去，对于N，则f(n) = f(n -1) + f(n - 5) + f(n - 10) + f(n - 20) + f(n - 50) + f(n - 100)，则用数组res记录1～N的组合数可以得到下表。</p></blockquote><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>4</td></tr></tbody></table><p>下面给出代码</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> money = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> coins[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> res[] = <span class="keyword">new</span> <span class="keyword">long</span>[money + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= money; j ++) &#123;</span><br><span class="line">                <span class="comment">//如果j大于当前的最大钱币，就加上N-coins[i]的数量</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    res[j] += res[j - coins[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(res[money]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩形游戏"><a href="#矩形游戏" class="headerlink" title="矩形游戏"></a>矩形游戏</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote><p>给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。</p></blockquote><p><img src="https://uploadfiles.nowcoder.net/images/20170726/58_1501040380059_47BE7E63FCFEB94676970280264AA19A" alt="img"></p><h5 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h5><blockquote><p>依次选择每一根柱子，求出每一根柱子扩展出去的最大矩形，那么其中最大的矩形就是我们想要的。计算的时候选择柱子，向左向右扩展就可以计算，记录最大值。</p></blockquote><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">//向左扩展</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = i-<span class="number">1</span>; left &gt;= <span class="number">0</span>; left --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[left] &lt; arr[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp += arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> <span class="comment">//向右扩展</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = i + <span class="number">1</span>; right &lt; n; right ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[right] &lt; arr[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp += arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (maxArea &lt; temp) &#123;</span><br><span class="line">                maxArea = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出最大值</span></span><br><span class="line">        System.out.print(maxArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长公共字符串"><a href="#最长公共字符串" class="headerlink" title="最长公共字符串"></a>最长公共字符串</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote><p>给出两个字符串（可能包含空格）,找出其中最长的公共连续子串,输出其长度。</p></blockquote><h5 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h5><blockquote><p>1、把两个字符串分别以行和列组成一个二维矩阵。</p><p>2、比较二维矩阵中每个点对应行列字符中否相等，相等的话值设置为1，否则设置为0。</p><p>3、通过查找出值为1的最长对角线就能找到最长公共子串。</p></blockquote><p><img src="/2018/09/06/meituan/juzhen.jpeg" alt="">    </p><p>但是其实找矩阵最长的对角线是一件麻烦的事情，因此可以做出如下改版</p><blockquote><p>为了进一步优化算法的效率，我们可以再计算某个二维矩阵的值的时候顺便计算出来当前最长的公共子串的长度，即某个二维矩阵元素的值为1加上左上角的值，这样就避免了后续查找对角线长度的操作了。修改后的二维矩阵如下：</p></blockquote><p><img src="/2018/09/06/meituan/juzhen1.jpeg" alt=""></p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = scanner.nextLine();</span><br><span class="line">        String str2 = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> row = str1.length();</span><br><span class="line">        <span class="keyword">int</span> col = str2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (str1.length() &gt; <span class="number">50</span> || str2.length() &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的字符串长度超限！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;=<span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    max = max &gt; dp[i][j] ? max : dp[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;美团秋招算法题目&quot;&gt;&lt;a href=&quot;#美团秋招算法题目&quot; class=&quot;headerlink&quot; title=&quot;美团秋招算法题目&quot;&gt;&lt;/a&gt;美团秋招算法题目&lt;/h3&gt;&lt;h4 id=&quot;大富翁游戏&quot;&gt;&lt;a href=&quot;#大富翁游戏&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="美团" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
      <category term="面试算法" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>年会算法题目</title>
    <link href="http://yoursite.com/2018/09/05/nianparty/"/>
    <id>http://yoursite.com/2018/09/05/nianparty/</id>
    <published>2018-09-05T09:29:15.000Z</published>
    <updated>2019-04-24T07:46:30.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公司年会算法题"><a href="#公司年会算法题" class="headerlink" title="公司年会算法题"></a>公司年会算法题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>N个人参与游戏，站成一排来抢工作人抛来的M个小玩偶。为了增加游戏的趣味和难度，规则规定，参与游戏的人抢到的礼物不能比左右两边的人多两个或以上，否则会受到一定的惩罚。游戏结束时拥有玩偶最多的人将获得一份大奖。<br>假设大家都想赢得这份大奖，请问站在第K个位置的小招在赢得游戏时，最多能拥有几个玩偶？</p></blockquote><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p><img src="/2018/09/05/nianparty/20180905-174315.png" alt=""></p><p>如图所示，假设站在k位置的小招最多拥有p个玩偶，非阴影部分为M，阴影部分为s，两部分加起来就是np，假设三角形的边长为x，而玩偶的数目为f(x)，可得<strong>f(x) = f(x - 1) + x </strong>(图形的垂直高度对应着玩偶的数量)，所以分别计算两个三角形表示的玩偶数目可得到如下的公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (k-1)k/2 + (n-k+1)(n-k)/2</span><br></pre></td></tr></table></figure></p><p>考虑可能多余i个玩偶，则从玩偶数量最少的人选择i个发玩偶，则可以这样计算p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (m + s - i) / n</span><br></pre></td></tr></table></figure></p><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>用java实现该算法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//参与游戏的人数量</span></span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="comment">//发放的玩偶数</span></span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        <span class="comment">//小招站的位置</span></span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || k &lt;=<span class="number">0</span> || m &lt;= <span class="number">0</span> || k &gt; n)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; k &gt;= <span class="number">1</span> &amp;&amp; m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//计算s的值</span></span><br><span class="line">            <span class="keyword">int</span> s = ((k - <span class="number">1</span>) * k &gt;&gt; <span class="number">1</span>) + ((n - k + <span class="number">1</span>) * (n - k) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">                <span class="comment">//迭代求解p值</span></span><br><span class="line">                <span class="keyword">if</span> ((m + s - i) % n == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println((m + s - i) / n);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;公司年会算法题&quot;&gt;&lt;a href=&quot;#公司年会算法题&quot; class=&quot;headerlink&quot; title=&quot;公司年会算法题&quot;&gt;&lt;/a&gt;公司年会算法题&lt;/h3&gt;&lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="招商银行" scheme="http://yoursite.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
      <category term="年会游戏" scheme="http://yoursite.com/tags/%E5%B9%B4%E4%BC%9A%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>nim游戏解法</title>
    <link href="http://yoursite.com/2018/09/04/nim/"/>
    <id>http://yoursite.com/2018/09/04/nim/</id>
    <published>2018-09-04T13:17:26.000Z</published>
    <updated>2019-04-24T07:46:17.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nim游戏及变种的算法题目"><a href="#Nim游戏及变种的算法题目" class="headerlink" title="Nim游戏及变种的算法题目"></a>Nim游戏及变种的算法题目</h3><h4 id="Nim游戏简介"><a href="#Nim游戏简介" class="headerlink" title="Nim游戏简介"></a>Nim游戏简介</h4><blockquote><p>有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。当然还有反Nim游戏，即拿到最后一个石子的人输。</p></blockquote><p>在求解Nim游戏前，我们给出P-position和N-position的定义：给出若干组二进制数，其二进制位对齐排列，把各列相加，如果各列得到的数字是偶数，那么它就是一个。以这个情况开局，或者在之后的某一手中，当前是一个安全组合，先手的人无论作出什么改变，都将使这个组合变为一个不安全的组合，而后手的人又总能由不安全的组合拼凑出一个安全的组合，我们称此时先手必败（后手必胜），这个局面称之为<strong>P-position</strong>，反之，若面临的是一个不安全组合，则其总有办法变为一个安全的组合，到下一个人进行时无论怎么改变都将成为一个不安全组合，此时后手必败（先手必胜），这个局面称之为<strong>N-position</strong>。</p><p>一下证明部分摘自知乎：<a href="https://www.zhihu.com/people/simonshao/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/simonshao/activities</a></p><blockquote><p>要知道，像Nim游戏这种博弈问题，最重要的是寻找必败态。这个必败态的的意思就是，这样一种局面摆在面前的话先手必败。其严格定义如下：1、无法进行任何移动的局面是必败态；2、可以移动到必败态的局面是非必败态；3、在必败态做的所有操作的结果都是非必败态。这个还是很好理解的吧，就是自己处在非必败态上总能移动到必败态把必败态留给对方，而对方处在必败态的话总是只能移动到非必败态，把非必败态留给自己，然后自己继续虐对方。</p></blockquote><p>证明：</p><blockquote><ul><li><p>第一个命题显然，最终局面只有一个，就是全0，a1^a2^…^ai’^…^an = 0。</p></li><li><p>第二个命题，对于某个局面(a1,a2,…,an)，若a1^a2^…^an不为0，一定存在某个合法的移动，将ai改变成ai’后满足a1^a2^…^ai’^…^an=0。不妨设a1^a2^…^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。则我们可以将ai改变成ai’=ai^k，此时a1^a2^…^ai’^…^an=a1^a2^…^an^k=0。</p></li><li><p>第三个命题，对于某个局面(a1,a2,…,an)，若a1^a2^…^an=0，一定不存在某个合法的移动，将ai改变成ai’后满足a1^a2^…^ai’^…^an=0。因为异或运算满足消去率，由a1^a2^…^an=a1^a2^…^ai’^…^an可以得到ai=ai’。所以将ai改变成ai’不是一个合法的移动。证毕。根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p></li></ul></blockquote><h4 id="Nim游戏衍生的算法题目"><a href="#Nim游戏衍生的算法题目" class="headerlink" title="Nim游戏衍生的算法题目"></a>Nim游戏衍生的算法题目</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote><p>按照卡中心校园招聘的要求，HR小招和小商需要从三个科室中（分别为A、B、C）抽派面试官去往不同城市。<br>两名HR按照以下规定轮流从任一科室选择面试官：每次至少选择一位，至多选择该科室剩余面试官数。最先选不到面试官的HR需要自己出差。<br>假设HR小招和小商都不想出差且每次选择都采取最优策略，如果是小招先选，写一个函数来判断她是否需要出差。如果不需要出差，请给出第一步的最优策略。</p></blockquote><h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>从上述Nim游戏的简介不难看出，这个题目也是Nim游戏问题，对于这个题目若A ^ B ^ C = 0，小招就是必败态，否则就得选择一定的数量的面试官，转移到必败态给小商选择。为了使选择之后A ^ B ^ C = 0，枚举两两的异或和，只有第三个的值大于这个异或值，选择第三个值减去另外两个数的异或值的差就可以保证获胜。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String inputData = scanner.nextLine();</span><br><span class="line">        String nums[] = inputData.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> A = Integer.parseInt(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> B = Integer.parseInt(nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> C = Integer.parseInt(nums[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> isOnBusiness = A ^ B ^ C;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isOnBusiness == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((A ^ B) &lt; C ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"C,"</span> + (C - (A ^ B)) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((A ^ C) &lt; B) &#123;</span><br><span class="line">            System.out.println(<span class="string">"B,"</span> + (B - (A ^ C)) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((B ^ C) &lt; A) &#123;</span><br><span class="line">            System.out.println(<span class="string">"A,"</span> + (A - (B ^ C)) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Nim游戏及变种的算法题目&quot;&gt;&lt;a href=&quot;#Nim游戏及变种的算法题目&quot; class=&quot;headerlink&quot; title=&quot;Nim游戏及变种的算法题目&quot;&gt;&lt;/a&gt;Nim游戏及变种的算法题目&lt;/h3&gt;&lt;h4 id=&quot;Nim游戏简介&quot;&gt;&lt;a href=&quot;#Ni
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="招商银行" scheme="http://yoursite.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
      <category term="Nim游戏" scheme="http://yoursite.com/tags/Nim%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>hadoop伪分布式安装过程</title>
    <link href="http://yoursite.com/2018/09/04/hadoop/"/>
    <id>http://yoursite.com/2018/09/04/hadoop/</id>
    <published>2018-09-04T06:48:31.000Z</published>
    <updated>2019-04-24T07:43:14.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hadoop-环境搭建"><a href="#hadoop-环境搭建" class="headerlink" title="hadoop 环境搭建"></a>hadoop 环境搭建</h3><h4 id="搭建的软件版本"><a href="#搭建的软件版本" class="headerlink" title="搭建的软件版本"></a>搭建的软件版本</h4><ul><li>ubuntu 16.04</li><li>hadoop 2.6.5</li><li>java 1.8</li></ul><p>在搭建hadoop环境之前，必须搭建好java的开发环境。</p><h4 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h4><ul><li>在java官网上下载合适版本的jdk</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</span><br></pre></td></tr></table></figure><ul><li>解压java安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>在/etc/profile中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/hadoop/jdk1.8.0_181  //此处替换jdk安装路径</span><br><span class="line">export JAVA_JRE=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h4 id="hadoop环境搭建"><a href="#hadoop环境搭建" class="headerlink" title="hadoop环境搭建"></a>hadoop环境搭建</h4><h5 id="创建hadoop用户"><a href="#创建hadoop用户" class="headerlink" title="创建hadoop用户"></a>创建hadoop用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m hadoop   //创建hadoop用户 </span><br><span class="line">sudo passwd hadoop          //为hadoop用户设置密码</span><br><span class="line">sudo adduser  hadoop sudo  //为hadoop用户添加管理元权限</span><br></pre></td></tr></table></figure><h5 id="安装ssh，配置无密登录"><a href="#安装ssh，配置无密登录" class="headerlink" title="安装ssh，配置无密登录"></a>安装ssh，配置无密登录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><ul><li>首次登录，可能需要输入密码才可以，但是会在用户文件夹下面创建.ssh的文件夹</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p>进入用户的.ssh文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh/                     # 若没有该目录，请先执行一次ssh localhost</span><br><span class="line">ssh-keygen -t rsa              # 会有提示，都按回车就可以</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 加入授权</span><br></pre></td></tr></table></figure><p>此时再登录localhost就不用再输入密码。</p><h5 id="在hadoop官网下载合适的版本，这里下载的hadoop2-6-5，下载地址："><a href="#在hadoop官网下载合适的版本，这里下载的hadoop2-6-5，下载地址：" class="headerlink" title="在hadoop官网下载合适的版本，这里下载的hadoop2.6.5，下载地址："></a>在hadoop官网下载合适的版本，这里下载的hadoop2.6.5，下载地址：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirror.bit.edu.cn/apache/hadoop/common/</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.6.5.tar.gz</span><br></pre></td></tr></table></figure><p>重命名解压后的文件夹并给文件夹的权限给hadoop用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv ./hadoop-2.6.5/ ./hadoop</span><br><span class="line">sudo chown hadoop ./hadoop</span><br></pre></td></tr></table></figure></p><p>进入hadoop安装目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/hadoop/hadoop</span><br><span class="line">./bin/hadoop version</span><br></pre></td></tr></table></figure></p><p>便可以看到hadoop的版本</p><h5 id="hadoop单击配置（非分布式）"><a href="#hadoop单击配置（非分布式）" class="headerlink" title="hadoop单击配置（非分布式）"></a>hadoop单击配置（非分布式）</h5><p>非分布式的环境下无需进行其他配置，可以直接跑hadoop里面附带的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /home/hadoop/hadoop</span><br><span class="line">mkdir ./input</span><br><span class="line">cp ./etc/hadoop/*.xml ./input   # 将配置文件作为输入文件</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output &apos;dfs[a-z.]+&apos;</span><br><span class="line">cat ./output/*</span><br></pre></td></tr></table></figure></p><h5 id="hadoop-伪分布式环境配置"><a href="#hadoop-伪分布式环境配置" class="headerlink" title="hadoop 伪分布式环境配置"></a>hadoop 伪分布式环境配置</h5><p>hadoop的配置文件再hadoo安装目录下的/etc/hadoop目录下面，如在我的环境里就是  /home/hadoop/hadoop/etc/hadoop下面</p><ul><li>修改core-site.xml配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/home/hadoop/hadoop/tmp&lt;/value&gt;</span><br><span class="line">             &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li>同样还得修改hdfs-site.xml文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>hadoop配置文件说明</strong><br>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p></blockquote><blockquote><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p></blockquote><p>配置完成之后需要格式化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></p><p>格式化完成之后就可以启动hdfs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></p><p>如果安装java并且配置了环境变量，但是在启动时还是报错：<strong>Error: JAVA_HOME is not set and could not be found.</strong> 则需要在hadoop/etc/hadoop（hadoop为hadoop安装）目录下修改hadoop-env.sh文件，在里面加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/hadoop/jdk1.8.0_181</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hadoop-环境搭建&quot;&gt;&lt;a href=&quot;#hadoop-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;hadoop 环境搭建&quot;&gt;&lt;/a&gt;hadoop 环境搭建&lt;/h3&gt;&lt;h4 id=&quot;搭建的软件版本&quot;&gt;&lt;a href=&quot;#搭建的软件版本&quot; c
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="分布式计算" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>实习经历</title>
    <link href="http://yoursite.com/2018/08/23/index/"/>
    <id>http://yoursite.com/2018/08/23/index/</id>
    <published>2018-08-23T05:46:25.000Z</published>
    <updated>2018-11-27T05:54:50.767Z</updated>
    
    <content type="html"><![CDATA[<p>每一段历程都会是自己人生的财富，感恩在这儿的每一个人！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每一段历程都会是自己人生的财富，感恩在这儿的每一个人！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
